(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: grpc/health/v1/health.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving eq]'
    opens=[]
    int64_as_int=false
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=true
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Grpc : sig
  module rec Health : sig
    module rec V1 : sig
      module rec HealthCheckRequest : sig
        type t = (string) [@@deriving eq]
        val make: ?service:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthCheckResponse : sig
        module rec ServingStatus : sig
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        type t = (ServingStatus.t) [@@deriving eq]
        val make: ?status:ServingStatus.t -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?status:ServingStatus.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListRequest : sig
        type t = unit [@@deriving eq]
        val make: unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListResponse : sig
        type t = ((string * HealthCheckResponse.t option) list) [@@deriving eq]
        (**
{%html:
<p>statuses contains all the services and their respective status.</p>
%}
        *)

        val make: ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module Health : sig
        module Check : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val check : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
        module List : sig
          include Runtime'.Service.Rpc with type Request.t = HealthListRequest.t and type Response.t = HealthListResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthListRequest.t and type make_t = HealthListRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthListResponse.t and type make_t = HealthListResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val list : (module Runtime'.Spec.Message with type t = HealthListRequest.t) * (module Runtime'.Spec.Message with type t = HealthListResponse.t)
        module Watch : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val watch : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
      end

    end
  end
end = struct
  module rec Health : sig
    module rec V1 : sig
      module rec HealthCheckRequest : sig
        type t = (string) [@@deriving eq]
        val make: ?service:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthCheckResponse : sig
        module rec ServingStatus : sig
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        type t = (ServingStatus.t) [@@deriving eq]
        val make: ?status:ServingStatus.t -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?status:ServingStatus.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListRequest : sig
        type t = unit [@@deriving eq]
        val make: unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListResponse : sig
        type t = ((string * HealthCheckResponse.t option) list) [@@deriving eq]
        (**
{%html:
<p>statuses contains all the services and their respective status.</p>
%}
        *)

        val make: ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module Health : sig
        module Check : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val check : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
        module List : sig
          include Runtime'.Service.Rpc with type Request.t = HealthListRequest.t and type Response.t = HealthListResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthListRequest.t and type make_t = HealthListRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthListResponse.t and type make_t = HealthListResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val list : (module Runtime'.Spec.Message with type t = HealthListRequest.t) * (module Runtime'.Spec.Message with type t = HealthListResponse.t)
        module Watch : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val watch : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
      end

    end
  end = struct
    module rec V1 : sig
      module rec HealthCheckRequest : sig
        type t = (string) [@@deriving eq]
        val make: ?service:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthCheckResponse : sig
        module rec ServingStatus : sig
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        type t = (ServingStatus.t) [@@deriving eq]
        val make: ?status:ServingStatus.t -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?status:ServingStatus.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListRequest : sig
        type t = unit [@@deriving eq]
        val make: unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      and HealthListResponse : sig
        type t = ((string * HealthCheckResponse.t option) list) [@@deriving eq]
        (**
{%html:
<p>statuses contains all the services and their respective status.</p>
%}
        *)

        val make: ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module Health : sig
        module Check : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val check : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
        module List : sig
          include Runtime'.Service.Rpc with type Request.t = HealthListRequest.t and type Response.t = HealthListResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthListRequest.t and type make_t = HealthListRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthListResponse.t and type make_t = HealthListResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val list : (module Runtime'.Spec.Message with type t = HealthListRequest.t) * (module Runtime'.Spec.Message with type t = HealthListResponse.t)
        module Watch : sig
          include Runtime'.Service.Rpc with type Request.t = HealthCheckRequest.t and type Response.t = HealthCheckResponse.t
          module Request : Runtime'.Spec.Message with type t = HealthCheckRequest.t and type make_t = HealthCheckRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = HealthCheckResponse.t and type make_t = HealthCheckResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val watch : (module Runtime'.Spec.Message with type t = HealthCheckRequest.t) * (module Runtime'.Spec.Message with type t = HealthCheckResponse.t)
      end

    end = struct
      module rec HealthCheckRequest : sig
        type t = (string) [@@deriving eq]
        val make: ?service:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = HealthCheckRequest
        let name () = ".grpc.health.v1.HealthCheckRequest"
        type t = (string) [@@deriving eq]
        type make_t = ?service:string -> unit -> t
        let make ?(service = {||}) () = (service)
        let merge =
        let merge_service = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "service", "service"), string, ({||})) ) in
        fun (t1_service) (t2_service) -> merge_service t1_service t2_service
        let spec () = Runtime'.Spec.( basic ((1, "service", "service"), string, ({||})) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (service) -> serialize writer service

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor service = (service) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (service) -> serialize service
        let from_json_exn =
          let constructor service = (service) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and HealthCheckResponse : sig
        module rec ServingStatus : sig
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end

        type t = (ServingStatus.t) [@@deriving eq]
        val make: ?status:ServingStatus.t -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?status:ServingStatus.t -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = HealthCheckResponse
        module rec ServingStatus : sig
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          val name: unit -> string
          (** Fully qualified protobuf name of this enum *)

          (**/**)
          val to_int: t -> int
          val from_int: int -> t Runtime'.Result.t
          val from_int_exn: int -> t
          val to_string: t -> string
          val from_string_exn: string -> t
          (**/**)
        end = struct
          module This'_ = ServingStatus
          type t =
            | UNKNOWN
            | SERVING
            | NOT_SERVING
            | SERVICE_UNKNOWN
            (**
{%html:
<p>Used only by the Watch method.</p>
%}
            *)

          [@@deriving eq]
          let name () = ".grpc.health.v1.HealthCheckResponse.ServingStatus"
          let to_int = function
            | UNKNOWN -> 0
            | SERVING -> 1
            | NOT_SERVING -> 2
            | SERVICE_UNKNOWN -> 3
          let from_int_exn = function
            | 0 -> UNKNOWN
            | 1 -> SERVING
            | 2 -> NOT_SERVING
            | 3 -> SERVICE_UNKNOWN
            | n -> Runtime'.Result.raise (`Unknown_enum_value n)
          let from_int e = Runtime'.Result.catch (fun () -> from_int_exn e)
          let to_string = function
            | UNKNOWN -> "UNKNOWN"
            | SERVING -> "SERVING"
            | NOT_SERVING -> "NOT_SERVING"
            | SERVICE_UNKNOWN -> "SERVICE_UNKNOWN"
          let from_string_exn = function
            | "UNKNOWN" -> UNKNOWN
            | "SERVING" -> SERVING
            | "NOT_SERVING" -> NOT_SERVING
            | "SERVICE_UNKNOWN" -> SERVICE_UNKNOWN
            | s -> Runtime'.Result.raise (`Unknown_enum_name s)

        end

        let name () = ".grpc.health.v1.HealthCheckResponse"
        type t = (ServingStatus.t) [@@deriving eq]
        type make_t = ?status:ServingStatus.t -> unit -> t
        let make ?(status = ServingStatus.from_int_exn 0) () = (status)
        let merge =
        let merge_status = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "status", "status"), (enum (module ServingStatus)), (ServingStatus.from_int_exn 0)) ) in
        fun (t1_status) (t2_status) -> merge_status t1_status t2_status
        let spec () = Runtime'.Spec.( basic ((1, "status", "status"), (enum (module ServingStatus)), (ServingStatus.from_int_exn 0)) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (status) -> serialize writer status

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor status = (status) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (status) -> serialize status
        let from_json_exn =
          let constructor status = (status) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and HealthListRequest : sig
        type t = unit [@@deriving eq]
        val make: unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = HealthListRequest
        let name () = ".grpc.health.v1.HealthListRequest"
        type t = unit [@@deriving eq]
        type make_t = unit -> t
        let make () = ()
        let merge =

        fun () () -> ()
        let spec () = Runtime'.Spec.( nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer () -> serialize writer

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor  = () in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun () -> serialize
        let from_json_exn =
          let constructor  = () in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and HealthListResponse : sig
        type t = ((string * HealthCheckResponse.t option) list) [@@deriving eq]
        (**
{%html:
<p>statuses contains all the services and their respective status.</p>
%}
        *)

        val make: ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = HealthListResponse
        let name () = ".grpc.health.v1.HealthListResponse"
        type t = ((string * HealthCheckResponse.t option) list) [@@deriving eq]
        type make_t = ?statuses:(string * HealthCheckResponse.t option) list -> unit -> t
        let make ?(statuses = []) () = (statuses)
        let merge =
        let merge_statuses = Runtime'.Merge.merge Runtime'.Spec.( map ((1, "statuses", "statuses"), (string, basic_opt ((2, "value", "value"), (message (module HealthCheckResponse))))) ) in
        fun (t1_statuses) (t2_statuses) -> merge_statuses t1_statuses t2_statuses
        let spec () = Runtime'.Spec.( map ((1, "statuses", "statuses"), (string, basic_opt ((2, "value", "value"), (message (module HealthCheckResponse))))) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (statuses) -> serialize writer statuses

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor statuses = (statuses) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (statuses) -> serialize statuses
        let from_json_exn =
          let constructor statuses = (statuses) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      module Health = struct
        module Check = struct
          let package_name = Some "grpc.health.v1"
          let service_name = "Health"
          let method_name = "Check"
          let name = "/grpc.health.v1.Health/Check"
          module Request = HealthCheckRequest
          module Response = HealthCheckResponse
        end

        let check =
          (module HealthCheckRequest : Runtime'.Spec.Message with type t = HealthCheckRequest.t ),
          (module HealthCheckResponse : Runtime'.Spec.Message with type t = HealthCheckResponse.t )

        module List = struct
          let package_name = Some "grpc.health.v1"
          let service_name = "Health"
          let method_name = "List"
          let name = "/grpc.health.v1.Health/List"
          module Request = HealthListRequest
          module Response = HealthListResponse
        end

        let list =
          (module HealthListRequest : Runtime'.Spec.Message with type t = HealthListRequest.t ),
          (module HealthListResponse : Runtime'.Spec.Message with type t = HealthListResponse.t )

        module Watch = struct
          let package_name = Some "grpc.health.v1"
          let service_name = "Health"
          let method_name = "Watch"
          let name = "/grpc.health.v1.Health/Watch"
          module Request = HealthCheckRequest
          module Response = HealthCheckResponse
        end

        let watch =
          (module HealthCheckRequest : Runtime'.Spec.Message with type t = HealthCheckRequest.t ),
          (module HealthCheckResponse : Runtime'.Spec.Message with type t = HealthCheckResponse.t )

      end

    end
  end
end

