(********************************************************)
(*           AUTOGENERATED FILE - DO NOT EDIT!          *)
(********************************************************)
(* Generated by: ocaml-protoc-plugin                    *)
(* https://github.com/andersfugmann/ocaml-protoc-plugin *)
(********************************************************)
(*
  Source: grpc/reflection/v1/reflection.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving eq]'
    opens=[]
    int64_as_int=false
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
    prefix_output_with_package=true
*)
[@@@ocaml.alert "-protobuf"] (* Disable deprecation warnings for protobuf*)
(**/**)
module Runtime' = Ocaml_protoc_plugin [@@warning "-33"]
module Imported'modules = struct
end
(**/**)
module rec Grpc : sig
  module rec Reflection : sig
    module rec V1 : sig

      (**
{%html:
<p>The message sent by the client when calling ServerReflectionInfo method.</p>
%}
      *)
      module rec ServerReflectionRequest : sig
        type t = {
          host:string;
          message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ];
          (**
{%html:
<p>To use reflection service, the client should set one of the following
fields in message_request. The server distinguishes requests by their
defined field and then handles them using corresponding methods.</p>
%}

            [`File_by_filename]
{%html:
<p>Find a proto file by the file name.</p>
%}


            [`File_containing_symbol]
{%html:
<p>Find the proto file that declares the given fully-qualified symbol name.
This field should be a fully-qualified symbol name
(e.g. <package>.<service>[.<method>] or <package>.<type>).</p>
%}


            [`File_containing_extension]
{%html:
<p>Find the proto file which defines an extension extending the given
message type with the given field number.</p>
%}


            [`All_extension_numbers_of_type]
{%html:
<p>Finds the tag numbers used by all known extensions of the given message
type, and appends them to ExtensionNumberResponse in an undefined order.
Its corresponding method is best-effort: it's not guaranteed that the
reflection service will implement this method, and it's not guaranteed
that this method will provide all extensions. Returns
StatusCode::UNIMPLEMENTED if it's not implemented.
This field should be a fully-qualified type name. The format is
<package>.<type></p>
%}


            [`List_services]
{%html:
<p>List the full names of registered services. The content will not be
checked.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The type name and extension number sent by the client when requesting
file_containing_extension.</p>
%}
      *)
      and ExtensionRequest : sig
        type t = {
          containing_type:string;
          (**
{%html:
<p>Fully-qualified type name. The format should be <package>.<type></p>
%}
          *)

          extension_number:int;
        } [@@deriving eq]
        val make: ?containing_type:string -> ?extension_number:int -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?containing_type:string -> ?extension_number:int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The message sent by the server to answer ServerReflectionInfo method.</p>
%}
      *)
      and ServerReflectionResponse : sig
        type t = {
          valid_host:string;
          original_request:ServerReflectionRequest.t option;
          message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ];
          (**
{%html:
<p>The server sets one of the following fields according to the message_request
in the request.</p>
%}

            [`File_descriptor_response]
{%html:
<p>This message is used to answer file_by_filename, file_containing_symbol,
file_containing_extension requests with transitive dependencies.
As the repeated label is not allowed in oneof fields, we use a
FileDescriptorResponse message to encapsulate the repeated fields.
The reflection service is allowed to avoid sending FileDescriptorProtos
that were previously sent in response to earlier requests in the stream.</p>
%}


            [`All_extension_numbers_response]
{%html:
<p>This message is used to answer all_extension_numbers_of_type requests.</p>
%}


            [`List_services_response]
{%html:
<p>This message is used to answer list_services requests.</p>
%}


            [`Error_response]
{%html:
<p>This message is used when an error occurs.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>Serialized FileDescriptorProto messages sent by the server answering
a file_by_filename, file_containing_symbol, or file_containing_extension
request.</p>
%}
      *)
      and FileDescriptorResponse : sig
        type t = (bytes list) [@@deriving eq]
        (**
{%html:
<p>Serialized FileDescriptorProto messages. We avoid taking a dependency on
descriptor.proto, which uses proto2 only features, by making them opaque
bytes instead.</p>
%}
        *)

        val make: ?file_descriptor_proto:bytes list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_descriptor_proto:bytes list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of extension numbers sent by the server answering
all_extension_numbers_of_type request.</p>
%}
      *)
      and ExtensionNumberResponse : sig
        type t = {
          base_type_name:string;
          (**
{%html:
<p>Full name of the base type, including the package name. The format
is <package>.<type></p>
%}
          *)

          extension_number:int list;
        } [@@deriving eq]
        val make: ?base_type_name:string -> ?extension_number:int list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?base_type_name:string -> ?extension_number:int list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of ServiceResponse sent by the server answering list_services request.</p>
%}
      *)
      and ListServiceResponse : sig
        type t = (ServiceResponse.t list) [@@deriving eq]
        (**
{%html:
<p>The information of each service may be expanded in the future, so we use
ServiceResponse message to encapsulate it.</p>
%}
        *)

        val make: ?service:ServiceResponse.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:ServiceResponse.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The information of a single service used by ListServiceResponse to answer
list_services request.</p>
%}
      *)
      and ServiceResponse : sig
        type t = (string) [@@deriving eq]
        (**
{%html:
<p>Full name of a registered service, including its package name. The format
is <package>.<service></p>
%}
        *)

        val make: ?name:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?name:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The error code and error message sent by the server when an error occurs.</p>
%}
      *)
      and ErrorResponse : sig
        type t = {
          error_code:int;
          (**
{%html:
<p>This field uses the error codes defined in grpc::StatusCode.</p>
%}
          *)

          error_message:string;
        } [@@deriving eq]
        val make: ?error_code:int -> ?error_message:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error_code:int -> ?error_message:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module ServerReflection : sig
        val package_service_name : string
        module ServerReflectionInfo : sig
          include Runtime'.Service.Rpc with type Request.t = ServerReflectionRequest.t and type Response.t = ServerReflectionResponse.t
          module Request : Runtime'.Spec.Message with type t = ServerReflectionRequest.t and type make_t = ServerReflectionRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = ServerReflectionResponse.t and type make_t = ServerReflectionResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val serverReflectionInfo : (module Runtime'.Spec.Message with type t = ServerReflectionRequest.t) * (module Runtime'.Spec.Message with type t = ServerReflectionResponse.t)
      end

    end
  end
end = struct
  module rec Reflection : sig
    module rec V1 : sig

      (**
{%html:
<p>The message sent by the client when calling ServerReflectionInfo method.</p>
%}
      *)
      module rec ServerReflectionRequest : sig
        type t = {
          host:string;
          message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ];
          (**
{%html:
<p>To use reflection service, the client should set one of the following
fields in message_request. The server distinguishes requests by their
defined field and then handles them using corresponding methods.</p>
%}

            [`File_by_filename]
{%html:
<p>Find a proto file by the file name.</p>
%}


            [`File_containing_symbol]
{%html:
<p>Find the proto file that declares the given fully-qualified symbol name.
This field should be a fully-qualified symbol name
(e.g. <package>.<service>[.<method>] or <package>.<type>).</p>
%}


            [`File_containing_extension]
{%html:
<p>Find the proto file which defines an extension extending the given
message type with the given field number.</p>
%}


            [`All_extension_numbers_of_type]
{%html:
<p>Finds the tag numbers used by all known extensions of the given message
type, and appends them to ExtensionNumberResponse in an undefined order.
Its corresponding method is best-effort: it's not guaranteed that the
reflection service will implement this method, and it's not guaranteed
that this method will provide all extensions. Returns
StatusCode::UNIMPLEMENTED if it's not implemented.
This field should be a fully-qualified type name. The format is
<package>.<type></p>
%}


            [`List_services]
{%html:
<p>List the full names of registered services. The content will not be
checked.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The type name and extension number sent by the client when requesting
file_containing_extension.</p>
%}
      *)
      and ExtensionRequest : sig
        type t = {
          containing_type:string;
          (**
{%html:
<p>Fully-qualified type name. The format should be <package>.<type></p>
%}
          *)

          extension_number:int;
        } [@@deriving eq]
        val make: ?containing_type:string -> ?extension_number:int -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?containing_type:string -> ?extension_number:int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The message sent by the server to answer ServerReflectionInfo method.</p>
%}
      *)
      and ServerReflectionResponse : sig
        type t = {
          valid_host:string;
          original_request:ServerReflectionRequest.t option;
          message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ];
          (**
{%html:
<p>The server sets one of the following fields according to the message_request
in the request.</p>
%}

            [`File_descriptor_response]
{%html:
<p>This message is used to answer file_by_filename, file_containing_symbol,
file_containing_extension requests with transitive dependencies.
As the repeated label is not allowed in oneof fields, we use a
FileDescriptorResponse message to encapsulate the repeated fields.
The reflection service is allowed to avoid sending FileDescriptorProtos
that were previously sent in response to earlier requests in the stream.</p>
%}


            [`All_extension_numbers_response]
{%html:
<p>This message is used to answer all_extension_numbers_of_type requests.</p>
%}


            [`List_services_response]
{%html:
<p>This message is used to answer list_services requests.</p>
%}


            [`Error_response]
{%html:
<p>This message is used when an error occurs.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>Serialized FileDescriptorProto messages sent by the server answering
a file_by_filename, file_containing_symbol, or file_containing_extension
request.</p>
%}
      *)
      and FileDescriptorResponse : sig
        type t = (bytes list) [@@deriving eq]
        (**
{%html:
<p>Serialized FileDescriptorProto messages. We avoid taking a dependency on
descriptor.proto, which uses proto2 only features, by making them opaque
bytes instead.</p>
%}
        *)

        val make: ?file_descriptor_proto:bytes list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_descriptor_proto:bytes list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of extension numbers sent by the server answering
all_extension_numbers_of_type request.</p>
%}
      *)
      and ExtensionNumberResponse : sig
        type t = {
          base_type_name:string;
          (**
{%html:
<p>Full name of the base type, including the package name. The format
is <package>.<type></p>
%}
          *)

          extension_number:int list;
        } [@@deriving eq]
        val make: ?base_type_name:string -> ?extension_number:int list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?base_type_name:string -> ?extension_number:int list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of ServiceResponse sent by the server answering list_services request.</p>
%}
      *)
      and ListServiceResponse : sig
        type t = (ServiceResponse.t list) [@@deriving eq]
        (**
{%html:
<p>The information of each service may be expanded in the future, so we use
ServiceResponse message to encapsulate it.</p>
%}
        *)

        val make: ?service:ServiceResponse.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:ServiceResponse.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The information of a single service used by ListServiceResponse to answer
list_services request.</p>
%}
      *)
      and ServiceResponse : sig
        type t = (string) [@@deriving eq]
        (**
{%html:
<p>Full name of a registered service, including its package name. The format
is <package>.<service></p>
%}
        *)

        val make: ?name:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?name:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The error code and error message sent by the server when an error occurs.</p>
%}
      *)
      and ErrorResponse : sig
        type t = {
          error_code:int;
          (**
{%html:
<p>This field uses the error codes defined in grpc::StatusCode.</p>
%}
          *)

          error_message:string;
        } [@@deriving eq]
        val make: ?error_code:int -> ?error_message:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error_code:int -> ?error_message:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module ServerReflection : sig
        val package_service_name : string
        module ServerReflectionInfo : sig
          include Runtime'.Service.Rpc with type Request.t = ServerReflectionRequest.t and type Response.t = ServerReflectionResponse.t
          module Request : Runtime'.Spec.Message with type t = ServerReflectionRequest.t and type make_t = ServerReflectionRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = ServerReflectionResponse.t and type make_t = ServerReflectionResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val serverReflectionInfo : (module Runtime'.Spec.Message with type t = ServerReflectionRequest.t) * (module Runtime'.Spec.Message with type t = ServerReflectionResponse.t)
      end

    end
  end = struct
    module rec V1 : sig

      (**
{%html:
<p>The message sent by the client when calling ServerReflectionInfo method.</p>
%}
      *)
      module rec ServerReflectionRequest : sig
        type t = {
          host:string;
          message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ];
          (**
{%html:
<p>To use reflection service, the client should set one of the following
fields in message_request. The server distinguishes requests by their
defined field and then handles them using corresponding methods.</p>
%}

            [`File_by_filename]
{%html:
<p>Find a proto file by the file name.</p>
%}


            [`File_containing_symbol]
{%html:
<p>Find the proto file that declares the given fully-qualified symbol name.
This field should be a fully-qualified symbol name
(e.g. <package>.<service>[.<method>] or <package>.<type>).</p>
%}


            [`File_containing_extension]
{%html:
<p>Find the proto file which defines an extension extending the given
message type with the given field number.</p>
%}


            [`All_extension_numbers_of_type]
{%html:
<p>Finds the tag numbers used by all known extensions of the given message
type, and appends them to ExtensionNumberResponse in an undefined order.
Its corresponding method is best-effort: it's not guaranteed that the
reflection service will implement this method, and it's not guaranteed
that this method will provide all extensions. Returns
StatusCode::UNIMPLEMENTED if it's not implemented.
This field should be a fully-qualified type name. The format is
<package>.<type></p>
%}


            [`List_services]
{%html:
<p>List the full names of registered services. The content will not be
checked.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The type name and extension number sent by the client when requesting
file_containing_extension.</p>
%}
      *)
      and ExtensionRequest : sig
        type t = {
          containing_type:string;
          (**
{%html:
<p>Fully-qualified type name. The format should be <package>.<type></p>
%}
          *)

          extension_number:int;
        } [@@deriving eq]
        val make: ?containing_type:string -> ?extension_number:int -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?containing_type:string -> ?extension_number:int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The message sent by the server to answer ServerReflectionInfo method.</p>
%}
      *)
      and ServerReflectionResponse : sig
        type t = {
          valid_host:string;
          original_request:ServerReflectionRequest.t option;
          message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ];
          (**
{%html:
<p>The server sets one of the following fields according to the message_request
in the request.</p>
%}

            [`File_descriptor_response]
{%html:
<p>This message is used to answer file_by_filename, file_containing_symbol,
file_containing_extension requests with transitive dependencies.
As the repeated label is not allowed in oneof fields, we use a
FileDescriptorResponse message to encapsulate the repeated fields.
The reflection service is allowed to avoid sending FileDescriptorProtos
that were previously sent in response to earlier requests in the stream.</p>
%}


            [`All_extension_numbers_response]
{%html:
<p>This message is used to answer all_extension_numbers_of_type requests.</p>
%}


            [`List_services_response]
{%html:
<p>This message is used to answer list_services requests.</p>
%}


            [`Error_response]
{%html:
<p>This message is used when an error occurs.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>Serialized FileDescriptorProto messages sent by the server answering
a file_by_filename, file_containing_symbol, or file_containing_extension
request.</p>
%}
      *)
      and FileDescriptorResponse : sig
        type t = (bytes list) [@@deriving eq]
        (**
{%html:
<p>Serialized FileDescriptorProto messages. We avoid taking a dependency on
descriptor.proto, which uses proto2 only features, by making them opaque
bytes instead.</p>
%}
        *)

        val make: ?file_descriptor_proto:bytes list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_descriptor_proto:bytes list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of extension numbers sent by the server answering
all_extension_numbers_of_type request.</p>
%}
      *)
      and ExtensionNumberResponse : sig
        type t = {
          base_type_name:string;
          (**
{%html:
<p>Full name of the base type, including the package name. The format
is <package>.<type></p>
%}
          *)

          extension_number:int list;
        } [@@deriving eq]
        val make: ?base_type_name:string -> ?extension_number:int list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?base_type_name:string -> ?extension_number:int list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>A list of ServiceResponse sent by the server answering list_services request.</p>
%}
      *)
      and ListServiceResponse : sig
        type t = (ServiceResponse.t list) [@@deriving eq]
        (**
{%html:
<p>The information of each service may be expanded in the future, so we use
ServiceResponse message to encapsulate it.</p>
%}
        *)

        val make: ?service:ServiceResponse.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:ServiceResponse.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The information of a single service used by ListServiceResponse to answer
list_services request.</p>
%}
      *)
      and ServiceResponse : sig
        type t = (string) [@@deriving eq]
        (**
{%html:
<p>Full name of a registered service, including its package name. The format
is <package>.<service></p>
%}
        *)

        val make: ?name:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?name:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end


      (**
{%html:
<p>The error code and error message sent by the server when an error occurs.</p>
%}
      *)
      and ErrorResponse : sig
        type t = {
          error_code:int;
          (**
{%html:
<p>This field uses the error codes defined in grpc::StatusCode.</p>
%}
          *)

          error_message:string;
        } [@@deriving eq]
        val make: ?error_code:int -> ?error_message:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error_code:int -> ?error_message:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end

      module ServerReflection : sig
        val package_service_name : string
        module ServerReflectionInfo : sig
          include Runtime'.Service.Rpc with type Request.t = ServerReflectionRequest.t and type Response.t = ServerReflectionResponse.t
          module Request : Runtime'.Spec.Message with type t = ServerReflectionRequest.t and type make_t = ServerReflectionRequest.make_t
          (** Module alias for the request message for this method call *)

          module Response : Runtime'.Spec.Message with type t = ServerReflectionResponse.t and type make_t = ServerReflectionResponse.make_t
          (** Module alias for the response message for this method call *)

        end

        val serverReflectionInfo : (module Runtime'.Spec.Message with type t = ServerReflectionRequest.t) * (module Runtime'.Spec.Message with type t = ServerReflectionResponse.t)
      end

    end = struct
      module rec ServerReflectionRequest : sig
        type t = {
          host:string;
          message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ];
          (**
{%html:
<p>To use reflection service, the client should set one of the following
fields in message_request. The server distinguishes requests by their
defined field and then handles them using corresponding methods.</p>
%}

            [`File_by_filename]
{%html:
<p>Find a proto file by the file name.</p>
%}


            [`File_containing_symbol]
{%html:
<p>Find the proto file that declares the given fully-qualified symbol name.
This field should be a fully-qualified symbol name
(e.g. <package>.<service>[.<method>] or <package>.<type>).</p>
%}


            [`File_containing_extension]
{%html:
<p>Find the proto file which defines an extension extending the given
message type with the given field number.</p>
%}


            [`All_extension_numbers_of_type]
{%html:
<p>Finds the tag numbers used by all known extensions of the given message
type, and appends them to ExtensionNumberResponse in an undefined order.
Its corresponding method is best-effort: it's not guaranteed that the
reflection service will implement this method, and it's not guaranteed
that this method will provide all extensions. Returns
StatusCode::UNIMPLEMENTED if it's not implemented.
This field should be a fully-qualified type name. The format is
<package>.<type></p>
%}


            [`List_services]
{%html:
<p>List the full names of registered services. The content will not be
checked.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ServerReflectionRequest
        let name () = ".grpc.reflection.v1.ServerReflectionRequest"
        type t = {
          host:string;
          message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ];
        } [@@deriving eq]
        type make_t = ?host:string -> ?message_request:[ `not_set | `File_by_filename of string | `File_containing_symbol of string | `File_containing_extension of ExtensionRequest.t | `All_extension_numbers_of_type of string | `List_services of string ] -> unit -> t
        let make ?(host = {||}) ?(message_request = `not_set) () = { host; message_request }
        let merge =
        let merge_host = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "host", "host"), string, ({||})) ) in
        let merge_oneof_message_request__File_by_filename = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), string) ) in
        let merge_oneof_message_request__File_containing_symbol = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), string) ) in
        let merge_oneof_message_request__File_containing_extension = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module ExtensionRequest))) ) in
        let merge_oneof_message_request__All_extension_numbers_of_type = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), string) ) in
        let merge_oneof_message_request__List_services = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), string) ) in
        fun t1 t2 -> {
        	host = (merge_host t1.host t2.host);
        	message_request = (match (t1.message_request, t2.message_request) with
        	| (`File_by_filename v1, `File_by_filename v2) -> `File_by_filename (merge_oneof_message_request__File_by_filename v1 v2)
        	| (`File_containing_symbol v1, `File_containing_symbol v2) -> `File_containing_symbol (merge_oneof_message_request__File_containing_symbol v1 v2)
        	| (`File_containing_extension v1, `File_containing_extension v2) -> `File_containing_extension (merge_oneof_message_request__File_containing_extension v1 v2)
        	| (`All_extension_numbers_of_type v1, `All_extension_numbers_of_type v2) -> `All_extension_numbers_of_type (merge_oneof_message_request__All_extension_numbers_of_type v1 v2)
        	| (`List_services v1, `List_services v2) -> `List_services (merge_oneof_message_request__List_services v1 v2)
        	| (v1, `not_set) -> v1
        	| (_, v2) -> v2);
         }
        let spec () = Runtime'.Spec.( basic ((1, "host", "host"), string, ({||})) ^:: oneof (([ oneof_elem ((3, "file_by_filename", "fileByFilename"), string, ((fun v -> `File_by_filename v), (function `File_by_filename v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((4, "file_containing_symbol", "fileContainingSymbol"), string, ((fun v -> `File_containing_symbol v), (function `File_containing_symbol v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((5, "file_containing_extension", "fileContainingExtension"), (message (module ExtensionRequest)), ((fun v -> `File_containing_extension v), (function `File_containing_extension v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((6, "all_extension_numbers_of_type", "allExtensionNumbersOfType"), string, ((fun v -> `All_extension_numbers_of_type v), (function `All_extension_numbers_of_type v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((7, "list_services", "listServices"), string, ((fun v -> `List_services v), (function `List_services v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `File_by_filename _ -> 0 | `File_containing_symbol _ -> 1 | `File_containing_extension _ -> 2 | `All_extension_numbers_of_type _ -> 3 | `List_services _ -> 4))) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { host; message_request } -> serialize writer host message_request

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor host message_request = { host; message_request } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { host; message_request } -> serialize host message_request
        let from_json_exn =
          let constructor host message_request = { host; message_request } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ExtensionRequest : sig
        type t = {
          containing_type:string;
          (**
{%html:
<p>Fully-qualified type name. The format should be <package>.<type></p>
%}
          *)

          extension_number:int;
        } [@@deriving eq]
        val make: ?containing_type:string -> ?extension_number:int -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?containing_type:string -> ?extension_number:int -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ExtensionRequest
        let name () = ".grpc.reflection.v1.ExtensionRequest"
        type t = {
          containing_type:string;
          extension_number:int;
        } [@@deriving eq]
        type make_t = ?containing_type:string -> ?extension_number:int -> unit -> t
        let make ?(containing_type = {||}) ?(extension_number = 0) () = { containing_type; extension_number }
        let merge =
        let merge_containing_type = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "containing_type", "containingType"), string, ({||})) ) in
        let merge_extension_number = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "extension_number", "extensionNumber"), int32_int, (0)) ) in
        fun t1 t2 -> {
        	containing_type = (merge_containing_type t1.containing_type t2.containing_type);
        	extension_number = (merge_extension_number t1.extension_number t2.extension_number);
         }
        let spec () = Runtime'.Spec.( basic ((1, "containing_type", "containingType"), string, ({||})) ^:: basic ((2, "extension_number", "extensionNumber"), int32_int, (0)) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { containing_type; extension_number } -> serialize writer containing_type extension_number

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor containing_type extension_number = { containing_type; extension_number } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { containing_type; extension_number } -> serialize containing_type extension_number
        let from_json_exn =
          let constructor containing_type extension_number = { containing_type; extension_number } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ServerReflectionResponse : sig
        type t = {
          valid_host:string;
          original_request:ServerReflectionRequest.t option;
          message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ];
          (**
{%html:
<p>The server sets one of the following fields according to the message_request
in the request.</p>
%}

            [`File_descriptor_response]
{%html:
<p>This message is used to answer file_by_filename, file_containing_symbol,
file_containing_extension requests with transitive dependencies.
As the repeated label is not allowed in oneof fields, we use a
FileDescriptorResponse message to encapsulate the repeated fields.
The reflection service is allowed to avoid sending FileDescriptorProtos
that were previously sent in response to earlier requests in the stream.</p>
%}


            [`All_extension_numbers_response]
{%html:
<p>This message is used to answer all_extension_numbers_of_type requests.</p>
%}


            [`List_services_response]
{%html:
<p>This message is used to answer list_services requests.</p>
%}


            [`Error_response]
{%html:
<p>This message is used when an error occurs.</p>
%}

          *)

        } [@@deriving eq]
        val make: ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ServerReflectionResponse
        let name () = ".grpc.reflection.v1.ServerReflectionResponse"
        type t = {
          valid_host:string;
          original_request:ServerReflectionRequest.t option;
          message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ];
        } [@@deriving eq]
        type make_t = ?valid_host:string -> ?original_request:ServerReflectionRequest.t -> ?message_response:[ `not_set | `File_descriptor_response of FileDescriptorResponse.t | `All_extension_numbers_response of ExtensionNumberResponse.t | `List_services_response of ListServiceResponse.t | `Error_response of ErrorResponse.t ] -> unit -> t
        let make ?(valid_host = {||}) ?original_request ?(message_response = `not_set) () = { valid_host; original_request; message_response }
        let merge =
        let merge_valid_host = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "valid_host", "validHost"), string, ({||})) ) in
        let merge_original_request = Runtime'.Merge.merge Runtime'.Spec.( basic_opt ((2, "original_request", "originalRequest"), (message (module ServerReflectionRequest))) ) in
        let merge_oneof_message_response__File_descriptor_response = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module FileDescriptorResponse))) ) in
        let merge_oneof_message_response__All_extension_numbers_response = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module ExtensionNumberResponse))) ) in
        let merge_oneof_message_response__List_services_response = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module ListServiceResponse))) ) in
        let merge_oneof_message_response__Error_response = Runtime'.Merge.merge Runtime'.Spec.( basic_req ((0, "", ""), (message (module ErrorResponse))) ) in
        fun t1 t2 -> {
        	valid_host = (merge_valid_host t1.valid_host t2.valid_host);
        	original_request = (merge_original_request t1.original_request t2.original_request);
        	message_response = (match (t1.message_response, t2.message_response) with
        	| (`File_descriptor_response v1, `File_descriptor_response v2) -> `File_descriptor_response (merge_oneof_message_response__File_descriptor_response v1 v2)
        	| (`All_extension_numbers_response v1, `All_extension_numbers_response v2) -> `All_extension_numbers_response (merge_oneof_message_response__All_extension_numbers_response v1 v2)
        	| (`List_services_response v1, `List_services_response v2) -> `List_services_response (merge_oneof_message_response__List_services_response v1 v2)
        	| (`Error_response v1, `Error_response v2) -> `Error_response (merge_oneof_message_response__Error_response v1 v2)
        	| (v1, `not_set) -> v1
        	| (_, v2) -> v2);
         }
        let spec () = Runtime'.Spec.( basic ((1, "valid_host", "validHost"), string, ({||})) ^:: basic_opt ((2, "original_request", "originalRequest"), (message (module ServerReflectionRequest))) ^:: oneof (([ oneof_elem ((4, "file_descriptor_response", "fileDescriptorResponse"), (message (module FileDescriptorResponse)), ((fun v -> `File_descriptor_response v), (function `File_descriptor_response v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((5, "all_extension_numbers_response", "allExtensionNumbersResponse"), (message (module ExtensionNumberResponse)), ((fun v -> `All_extension_numbers_response v), (function `All_extension_numbers_response v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((6, "list_services_response", "listServicesResponse"), (message (module ListServiceResponse)), ((fun v -> `List_services_response v), (function `List_services_response v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))); oneof_elem ((7, "error_response", "errorResponse"), (message (module ErrorResponse)), ((fun v -> `Error_response v), (function `Error_response v -> v | _ -> raise (Invalid_argument "Cannot destruct given oneof")))) ], (function | `not_set -> failwith "Impossible case" | `File_descriptor_response _ -> 0 | `All_extension_numbers_response _ -> 1 | `List_services_response _ -> 2 | `Error_response _ -> 3))) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { valid_host; original_request; message_response } -> serialize writer valid_host original_request message_response

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor valid_host original_request message_response = { valid_host; original_request; message_response } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { valid_host; original_request; message_response } -> serialize valid_host original_request message_response
        let from_json_exn =
          let constructor valid_host original_request message_response = { valid_host; original_request; message_response } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and FileDescriptorResponse : sig
        type t = (bytes list) [@@deriving eq]
        (**
{%html:
<p>Serialized FileDescriptorProto messages. We avoid taking a dependency on
descriptor.proto, which uses proto2 only features, by making them opaque
bytes instead.</p>
%}
        *)

        val make: ?file_descriptor_proto:bytes list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?file_descriptor_proto:bytes list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = FileDescriptorResponse
        let name () = ".grpc.reflection.v1.FileDescriptorResponse"
        type t = (bytes list) [@@deriving eq]
        type make_t = ?file_descriptor_proto:bytes list -> unit -> t
        let make ?(file_descriptor_proto = []) () = (file_descriptor_proto)
        let merge =
        let merge_file_descriptor_proto = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "file_descriptor_proto", "fileDescriptorProto"), bytes, not_packed) ) in
        fun (t1_file_descriptor_proto) (t2_file_descriptor_proto) -> merge_file_descriptor_proto t1_file_descriptor_proto t2_file_descriptor_proto
        let spec () = Runtime'.Spec.( repeated ((1, "file_descriptor_proto", "fileDescriptorProto"), bytes, not_packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (file_descriptor_proto) -> serialize writer file_descriptor_proto

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor file_descriptor_proto = (file_descriptor_proto) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (file_descriptor_proto) -> serialize file_descriptor_proto
        let from_json_exn =
          let constructor file_descriptor_proto = (file_descriptor_proto) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ExtensionNumberResponse : sig
        type t = {
          base_type_name:string;
          (**
{%html:
<p>Full name of the base type, including the package name. The format
is <package>.<type></p>
%}
          *)

          extension_number:int list;
        } [@@deriving eq]
        val make: ?base_type_name:string -> ?extension_number:int list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?base_type_name:string -> ?extension_number:int list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ExtensionNumberResponse
        let name () = ".grpc.reflection.v1.ExtensionNumberResponse"
        type t = {
          base_type_name:string;
          extension_number:int list;
        } [@@deriving eq]
        type make_t = ?base_type_name:string -> ?extension_number:int list -> unit -> t
        let make ?(base_type_name = {||}) ?(extension_number = []) () = { base_type_name; extension_number }
        let merge =
        let merge_base_type_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "base_type_name", "baseTypeName"), string, ({||})) ) in
        let merge_extension_number = Runtime'.Merge.merge Runtime'.Spec.( repeated ((2, "extension_number", "extensionNumber"), int32_int, packed) ) in
        fun t1 t2 -> {
        	base_type_name = (merge_base_type_name t1.base_type_name t2.base_type_name);
        	extension_number = (merge_extension_number t1.extension_number t2.extension_number);
         }
        let spec () = Runtime'.Spec.( basic ((1, "base_type_name", "baseTypeName"), string, ({||})) ^:: repeated ((2, "extension_number", "extensionNumber"), int32_int, packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { base_type_name; extension_number } -> serialize writer base_type_name extension_number

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor base_type_name extension_number = { base_type_name; extension_number } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { base_type_name; extension_number } -> serialize base_type_name extension_number
        let from_json_exn =
          let constructor base_type_name extension_number = { base_type_name; extension_number } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ListServiceResponse : sig
        type t = (ServiceResponse.t list) [@@deriving eq]
        (**
{%html:
<p>The information of each service may be expanded in the future, so we use
ServiceResponse message to encapsulate it.</p>
%}
        *)

        val make: ?service:ServiceResponse.t list -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?service:ServiceResponse.t list -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ListServiceResponse
        let name () = ".grpc.reflection.v1.ListServiceResponse"
        type t = (ServiceResponse.t list) [@@deriving eq]
        type make_t = ?service:ServiceResponse.t list -> unit -> t
        let make ?(service = []) () = (service)
        let merge =
        let merge_service = Runtime'.Merge.merge Runtime'.Spec.( repeated ((1, "service", "service"), (message (module ServiceResponse)), not_packed) ) in
        fun (t1_service) (t2_service) -> merge_service t1_service t2_service
        let spec () = Runtime'.Spec.( repeated ((1, "service", "service"), (message (module ServiceResponse)), not_packed) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (service) -> serialize writer service

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor service = (service) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (service) -> serialize service
        let from_json_exn =
          let constructor service = (service) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ServiceResponse : sig
        type t = (string) [@@deriving eq]
        (**
{%html:
<p>Full name of a registered service, including its package name. The format
is <package>.<service></p>
%}
        *)

        val make: ?name:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?name:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ServiceResponse
        let name () = ".grpc.reflection.v1.ServiceResponse"
        type t = (string) [@@deriving eq]
        type make_t = ?name:string -> unit -> t
        let make ?(name = {||}) () = (name)
        let merge =
        let merge_name = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ) in
        fun (t1_name) (t2_name) -> merge_name t1_name t2_name
        let spec () = Runtime'.Spec.( basic ((1, "name", "name"), string, ({||})) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer (name) -> serialize writer name

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor name = (name) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun (name) -> serialize name
        let from_json_exn =
          let constructor name = (name) in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      and ErrorResponse : sig
        type t = {
          error_code:int;
          (**
{%html:
<p>This field uses the error codes defined in grpc::StatusCode.</p>
%}
          *)

          error_message:string;
        } [@@deriving eq]
        val make: ?error_code:int -> ?error_message:string -> unit -> t
        (** Helper function to generate a message using default values *)

        val to_proto: t -> Runtime'.Writer.t
        (** Serialize the message to binary format *)

        val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from binary format *)

        val to_json: Runtime'.Json_options.t -> t -> Runtime'.Json.t
        (** Serialize to Json (compatible with Yojson.Basic.t) *)

        val from_json: Runtime'.Json.t -> (t, [> Runtime'.Result.error]) result
        (** Deserialize from Json (compatible with Yojson.Basic.t) *)

        val name: unit -> string
        (** Fully qualified protobuf name of this message *)

        (**/**)
        type make_t = ?error_code:int -> ?error_message:string -> unit -> t
        val merge: t -> t -> t
        val to_proto': Runtime'.Writer.t -> t -> unit
        val from_proto_exn: Runtime'.Reader.t -> t
        val from_json_exn: Runtime'.Json.t -> t
        (**/**)
      end = struct
        module This'_ = ErrorResponse
        let name () = ".grpc.reflection.v1.ErrorResponse"
        type t = {
          error_code:int;
          error_message:string;
        } [@@deriving eq]
        type make_t = ?error_code:int -> ?error_message:string -> unit -> t
        let make ?(error_code = 0) ?(error_message = {||}) () = { error_code; error_message }
        let merge =
        let merge_error_code = Runtime'.Merge.merge Runtime'.Spec.( basic ((1, "error_code", "errorCode"), int32_int, (0)) ) in
        let merge_error_message = Runtime'.Merge.merge Runtime'.Spec.( basic ((2, "error_message", "errorMessage"), string, ({||})) ) in
        fun t1 t2 -> {
        	error_code = (merge_error_code t1.error_code t2.error_code);
        	error_message = (merge_error_message t1.error_message t2.error_message);
         }
        let spec () = Runtime'.Spec.( basic ((1, "error_code", "errorCode"), int32_int, (0)) ^:: basic ((2, "error_message", "errorMessage"), string, ({||})) ^:: nil )
        let to_proto' =
          let serialize = Runtime'.apply_lazy (fun () -> Runtime'.Serialize.serialize (spec ())) in
          fun writer { error_code; error_message } -> serialize writer error_code error_message

        let to_proto t = let writer = Runtime'.Writer.init () in to_proto' writer t; writer
        let from_proto_exn =
          let constructor error_code error_message = { error_code; error_message } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize.deserialize (spec ()) constructor)
        let from_proto writer = Runtime'.Result.catch (fun () -> from_proto_exn writer)
        let to_json options =
          let serialize = Runtime'.Serialize_json.serialize ~message_name:(name ()) (spec ()) options in
          fun { error_code; error_message } -> serialize error_code error_message
        let from_json_exn =
          let constructor error_code error_message = { error_code; error_message } in
          Runtime'.apply_lazy (fun () -> Runtime'.Deserialize_json.deserialize ~message_name:(name ()) (spec ()) constructor)
        let from_json json = Runtime'.Result.catch (fun () -> from_json_exn json)
      end

      module ServerReflection = struct
        let package_service_name = "grpc.reflection.v1.ServerReflection"
        module ServerReflectionInfo = struct
          let package_name = Some "grpc.reflection.v1"
          let service_name = "ServerReflection"
          let method_name = "ServerReflectionInfo"
          let name = "/grpc.reflection.v1.ServerReflection/ServerReflectionInfo"
          module Request = ServerReflectionRequest
          module Response = ServerReflectionResponse
        end

        let serverReflectionInfo =
          (module ServerReflectionRequest : Runtime'.Spec.Message with type t = ServerReflectionRequest.t ),
          (module ServerReflectionResponse : Runtime'.Spec.Message with type t = ServerReflectionResponse.t )

      end

    end
  end
end

module Metainfo : Runtime'.Spec.Metainfo = struct
  let file_name = "grpc/reflection/v1/reflection.proto"
  let file_descriptor_proto = "\n#grpc/reflection/v1/reflection.proto\018\018grpc.reflection.v1\"\243\002\n\023ServerReflectionRequest\018\018\n\004host\024\001 \001(\tR\004host\018*\n\016file_by_filename\024\003 \001(\tH\000R\014fileByFilename\0186\n\022file_containing_symbol\024\004 \001(\tH\000R\020fileContainingSymbol\018b\n\025file_containing_extension\024\005 \001(\0112$.grpc.reflection.v1.ExtensionRequestH\000R\023fileContainingExtension\018B\n\029all_extension_numbers_of_type\024\006 \001(\tH\000R\025allExtensionNumbersOfType\018%\n\rlist_services\024\007 \001(\tH\000R\012listServicesB\017\n\015message_request\"f\n\016ExtensionRequest\018'\n\015containing_type\024\001 \001(\tR\014containingType\018)\n\016extension_number\024\002 \001(\005R\015extensionNumber\"\174\004\n\024ServerReflectionResponse\018\029\n\nvalid_host\024\001 \001(\tR\tvalidHost\018V\n\016original_request\024\002 \001(\0112+.grpc.reflection.v1.ServerReflectionRequestR\015originalRequest\018f\n\024file_descriptor_response\024\004 \001(\0112*.grpc.reflection.v1.FileDescriptorResponseH\000R\022fileDescriptorResponse\018r\n\030all_extension_numbers_response\024\005 \001(\0112+.grpc.reflection.v1.ExtensionNumberResponseH\000R\027allExtensionNumbersResponse\018_\n\022list_services_response\024\006 \001(\0112'.grpc.reflection.v1.ListServiceResponseH\000R\020listServicesResponse\018J\n\014error_response\024\007 \001(\0112!.grpc.reflection.v1.ErrorResponseH\000R\rerrorResponseB\018\n\016message_response\"L\n\022FileDescriptorResponse\0182\n\021file_descriptor_proto\024\001 \003(\012R\019fileDescriptorProto\"j\n\023ExtensionNumberResponse\018$\n\014base_type_name\024\001 \001(\tR\012baseTypeName\018)\n\016extension_number\024\002 \003(\005R\015extensionNumber\"T\n\019ListServiceResponse\018=\n\007service\024\001 \003(\0112#.grpc.reflection.v1.ServiceResponseR\007service\"%\n\015ServiceResponse\018\018\n\004name\024\001 \001(\tR\004name\"S\n\rErrorResponse\018\029\n\nerror_code\024\001 \001(\005R\terrorCode\018#\n\rerror_message\024\002 \001(\tR\012errorMessage2\137\001\n\016ServerReflection\018u\n\020ServerReflectionInfo\018+.grpc.reflection.v1.ServerReflectionRequest\026,.grpc.reflection.v1.ServerReflectionResponse(\0010\001B\201\001\n\022com.grpc.reflection.v1B\015ReflectionProtoP\001Z4google.golang.org/grpc/reflection/grpc_reflection_v1\162\002\003GRX\170\002\018Grpc.Reflection.V1\202\002\018Grpc\\Reflection\\V1\226\002\030Grpc\\Reflection\\V1\\GPBMetadata\234\002\020Grpc::Reflection::V1J\231-\n\007\018\005\021\000\145\001\001\n\135\007\n\001\012\018\003\021\000\0182\183\004 Copyright 2016 The gRPC Authors\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n2\194\002 Service exported by server reflection.  A more complete description of how\n server reflection works can be found at\n https://github.com/grpc/grpc/blob/master/doc/server-reflection.md\n\n The canonical version of this proto can be found at\n https://github.com/grpc/grpc-proto/blob/master/grpc/reflection/v1/reflection.proto\n\n\b\n\001\002\018\003\023\000\027\n\b\n\001\b\018\003\025\000K\n\t\n\002\b\011\018\003\025\000K\n\b\n\001\b\018\003\026\000\"\n\t\n\002\b\n\018\003\026\000\"\n\n\n\002\006\000\018\004\030\000#\001\n\n\n\003\006\000\001\018\003\030\b\024\n\133\001\n\004\006\000\002\000\018\004!\002\"0\026w The reflection service is structured as a bidirectional stream, ensuring\n all related requests go to a single server.\n\n\012\n\005\006\000\002\000\001\018\003!\006\026\n\012\n\005\006\000\002\000\005\018\003!\027!\n\012\n\005\006\000\002\000\002\018\003!\"9\n\012\n\005\006\000\002\000\006\018\003\"\015\021\n\012\n\005\006\000\002\000\003\018\003\"\022.\nV\n\002\004\000\018\004&\000F\001\026J The message sent by the client when calling ServerReflectionInfo method.\n\n\n\n\003\004\000\001\018\003&\b\031\n\011\n\004\004\000\002\000\018\003'\002\018\n\012\n\005\004\000\002\000\005\018\003'\002\b\n\012\n\005\004\000\002\000\001\018\003'\t\r\n\012\n\005\004\000\002\000\003\018\003'\016\017\n\223\001\n\004\004\000\b\000\018\004+\002E\003\026\208\001 To use reflection service, the client should set one of the following\n fields in message_request. The server distinguishes requests by their\n defined field and then handles them using corresponding methods.\n\n\012\n\005\004\000\b\000\001\018\003+\b\023\n2\n\004\004\000\002\001\018\003-\004 \026% Find a proto file by the file name.\n\n\012\n\005\004\000\002\001\005\018\003-\004\n\n\012\n\005\004\000\002\001\001\018\003-\011\027\n\012\n\005\004\000\002\001\003\018\003-\030\031\n\200\001\n\004\004\000\002\002\018\0032\004&\026\186\001 Find the proto file that declares the given fully-qualified symbol name.\n This field should be a fully-qualified symbol name\n (e.g. <package>.<service>[.<method>] or <package>.<type>).\n\n\012\n\005\004\000\002\002\005\018\0032\004\n\n\012\n\005\004\000\002\002\001\018\0032\011!\n\012\n\005\004\000\002\002\003\018\0032$%\n|\n\004\004\000\002\003\018\0036\0043\026o Find the proto file which defines an extension extending the given\n message type with the given field number.\n\n\012\n\005\004\000\002\003\006\018\0036\004\020\n\012\n\005\004\000\002\003\001\018\0036\021.\n\012\n\005\004\000\002\003\003\018\003612\n\238\003\n\004\004\000\002\004\018\003@\004-\026\224\003 Finds the tag numbers used by all known extensions of the given message\n type, and appends them to ExtensionNumberResponse in an undefined order.\n Its corresponding method is best-effort: it's not guaranteed that the\n reflection service will implement this method, and it's not guaranteed\n that this method will provide all extensions. Returns\n StatusCode::UNIMPLEMENTED if it's not implemented.\n This field should be a fully-qualified type name. The format is\n <package>.<type>\n\n\012\n\005\004\000\002\004\005\018\003@\004\n\n\012\n\005\004\000\002\004\001\018\003@\011(\n\012\n\005\004\000\002\004\003\018\003@+,\n\\\n\004\004\000\002\005\018\003D\004\029\026O List the full names of registered services. The content will not be\n checked.\n\n\012\n\005\004\000\002\005\005\018\003D\004\n\n\012\n\005\004\000\002\005\001\018\003D\011\024\n\012\n\005\004\000\002\005\003\018\003D\027\028\no\n\002\004\001\018\004J\000N\001\026c The type name and extension number sent by the client when requesting\n file_containing_extension.\n\n\n\n\003\004\001\001\018\003J\b\024\nO\n\004\004\001\002\000\018\003L\002\029\026B Fully-qualified type name. The format should be <package>.<type>\n\n\012\n\005\004\001\002\000\005\018\003L\002\b\n\012\n\005\004\001\002\000\001\018\003L\t\024\n\012\n\005\004\001\002\000\003\018\003L\027\028\n\011\n\004\004\001\002\001\018\003M\002\029\n\012\n\005\004\001\002\001\005\018\003M\002\007\n\012\n\005\004\001\002\001\001\018\003M\b\024\n\012\n\005\004\001\002\001\003\018\003M\027\028\nS\n\002\004\002\018\004Q\000h\001\026G The message sent by the server to answer ServerReflectionInfo method.\n\n\n\n\003\004\002\001\018\003Q\b \n\011\n\004\004\002\002\000\018\003R\002\024\n\012\n\005\004\002\002\000\005\018\003R\002\b\n\012\n\005\004\002\002\000\001\018\003R\t\019\n\012\n\005\004\002\002\000\003\018\003R\022\023\n\011\n\004\004\002\002\001\018\003S\002/\n\012\n\005\004\002\002\001\006\018\003S\002\025\n\012\n\005\004\002\002\001\001\018\003S\026*\n\012\n\005\004\002\002\001\003\018\003S-.\nm\n\004\004\002\b\000\018\004V\002g\003\026_ The server sets one of the following fields according to the message_request\n in the request.\n\n\012\n\005\004\002\b\000\001\018\003V\b\024\n\177\003\n\004\004\002\002\002\018\003]\0048\026\163\003 This message is used to answer file_by_filename, file_containing_symbol,\n file_containing_extension requests with transitive dependencies.\n As the repeated label is not allowed in oneof fields, we use a\n FileDescriptorResponse message to encapsulate the repeated fields.\n The reflection service is allowed to avoid sending FileDescriptorProtos\n that were previously sent in response to earlier requests in the stream.\n\n\012\n\005\004\002\002\002\006\018\003]\004\026\n\012\n\005\004\002\002\002\001\018\003]\0273\n\012\n\005\004\002\002\002\003\018\003]67\nU\n\004\004\002\002\003\018\003`\004?\026H This message is used to answer all_extension_numbers_of_type requests.\n\n\012\n\005\004\002\002\003\006\018\003`\004\027\n\012\n\005\004\002\002\003\001\018\003`\028:\n\012\n\005\004\002\002\003\003\018\003`=>\nE\n\004\004\002\002\004\018\003c\0043\0268 This message is used to answer list_services requests.\n\n\012\n\005\004\002\002\004\006\018\003c\004\023\n\012\n\005\004\002\002\004\001\018\003c\024.\n\012\n\005\004\002\002\004\003\018\003c12\n9\n\004\004\002\002\005\018\003f\004%\026, This message is used when an error occurs.\n\n\012\n\005\004\002\002\005\006\018\003f\004\017\n\012\n\005\004\002\002\005\001\018\003f\018 \n\012\n\005\004\002\002\005\003\018\003f#$\n\167\001\n\002\004\003\018\004m\000r\001\026\154\001 Serialized FileDescriptorProto messages sent by the server answering\n a file_by_filename, file_containing_symbol, or file_containing_extension\n request.\n\n\n\n\003\004\003\001\018\003m\b\030\n\178\001\n\004\004\003\002\000\018\003q\002+\026\164\001 Serialized FileDescriptorProto messages. We avoid taking a dependency on\n descriptor.proto, which uses proto2 only features, by making them opaque\n bytes instead.\n\n\012\n\005\004\003\002\000\004\018\003q\002\n\n\012\n\005\004\003\002\000\005\018\003q\011\016\n\012\n\005\004\003\002\000\001\018\003q\017&\n\012\n\005\004\003\002\000\003\018\003q)*\nn\n\002\004\004\018\004v\000{\001\026b A list of extension numbers sent by the server answering\n all_extension_numbers_of_type request.\n\n\n\n\003\004\004\001\018\003v\b\031\nf\n\004\004\004\002\000\018\003y\002\028\026Y Full name of the base type, including the package name. The format\n is <package>.<type>\n\n\012\n\005\004\004\002\000\005\018\003y\002\b\n\012\n\005\004\004\002\000\001\018\003y\t\023\n\012\n\005\004\004\002\000\003\018\003y\026\027\n\011\n\004\004\004\002\001\018\003z\002&\n\012\n\005\004\004\002\001\004\018\003z\002\n\n\012\n\005\004\004\002\001\005\018\003z\011\016\n\012\n\005\004\004\002\001\001\018\003z\017!\n\012\n\005\004\004\002\001\003\018\003z$%\n\\\n\002\004\005\018\005~\000\130\001\001\026O A list of ServiceResponse sent by the server answering list_services request.\n\n\n\n\003\004\005\001\018\003~\b\027\n\132\001\n\004\004\005\002\000\018\004\129\001\002'\026v The information of each service may be expanded in the future, so we use\n ServiceResponse message to encapsulate it.\n\n\r\n\005\004\005\002\000\004\018\004\129\001\002\n\n\r\n\005\004\005\002\000\006\018\004\129\001\011\026\n\r\n\005\004\005\002\000\001\018\004\129\001\027\"\n\r\n\005\004\005\002\000\003\018\004\129\001%&\nq\n\002\004\006\018\006\134\001\000\138\001\001\026c The information of a single service used by ListServiceResponse to answer\n list_services request.\n\n\011\n\003\004\006\001\018\004\134\001\b\023\nq\n\004\004\006\002\000\018\004\137\001\002\018\026c Full name of a registered service, including its package name. The format\n is <package>.<service>\n\n\r\n\005\004\006\002\000\005\018\004\137\001\002\b\n\r\n\005\004\006\002\000\001\018\004\137\001\t\r\n\r\n\005\004\006\002\000\003\018\004\137\001\016\017\nY\n\002\004\007\018\006\141\001\000\145\001\001\026K The error code and error message sent by the server when an error occurs.\n\n\011\n\003\004\007\001\018\004\141\001\b\021\nL\n\004\004\007\002\000\018\004\143\001\002\023\026> This field uses the error codes defined in grpc::StatusCode.\n\n\r\n\005\004\007\002\000\005\018\004\143\001\002\007\n\r\n\005\004\007\002\000\001\018\004\143\001\b\018\n\r\n\005\004\007\002\000\003\018\004\143\001\021\022\n\012\n\004\004\007\002\001\018\004\144\001\002\027\n\r\n\005\004\007\002\001\005\018\004\144\001\002\b\n\r\n\005\004\007\002\001\001\018\004\144\001\t\022\n\r\n\005\004\007\002\001\003\018\004\144\001\025\026b\006proto3"
  let package_service_names = [
    "grpc.reflection.v1.ServerReflection";
  ]
end
